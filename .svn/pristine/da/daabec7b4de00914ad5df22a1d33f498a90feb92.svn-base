/*
 * Worklist.cpp
 *
 *  Created on: Dec 16, 2011
 *      Author: hsqfire
 */

#include "Worklist.h"
#include "../util/Log.h"
#include "iostream"

namespace esp {

esp::Work::~Work(){

}

esp::Worklist::Worklist() {
  works = set<Work*>();
}

esp::Worklist::~Worklist() {
  for(set<Work*>::iterator it = works.begin(); it!=works.end(); it++){
    Work *work = (*it);
    works.erase(it);
  }
}

void esp::Worklist::addToWorklist(Work* work){
  if(work!=NULL){
    for(set<Work*>::iterator it = works.begin();
        it != works.end(); it++)
      if((*it)->equalsTo(work))
        return;
    works.insert(work);
  }
}

void esp::Worklist::removeFromWorklist(Work *work){
  string info = "worklist size: ";
  stringstream ss;
  ss<<works.size();
  info += ss.str();
  info += "\ncurrent work: ";
  stringstream s2;
  s2<<(int)work;
  info += s2.str();
  for(set<Work*>::iterator it = works.begin(); it!=works.end(); it++){
    Work *workInList = (*it);
    info += "\nenum work: ";
    stringstream s3;
    s3<<(int)work;
    info += s3.str();
    if(workInList == work){
      works.erase(it);
      break;
    }
  }

  //printDebugMsg(info);
}

Work* esp::Worklist::selectAWork(){
  // Defaultly return the first element in the work list
  return (*works.begin());
}

void esp::Worklist::solveWorklist(){
  while(works.size() != 0){
    Work *currentWork = selectAWork();
    removeFromWorklist(currentWork);
    //do real work here
    if(currentWork != NULL)
      doEachWork(currentWork);

    printDebugMsg("Instructions in worklist:");
    for(set<Work*>::iterator it = works.begin(); it!=works.end(); it++){
      Work *workInList = (*it);
      workInList->printContent();
    }
  }
}

void esp::Worklist::initWorklist(){
  works.clear();
}

} /* namespace esp */
